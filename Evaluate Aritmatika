#include <iostream>
#include <vector>
#include <string>
#include <stack>
#include <cctype>
#include <cmath>
using namespace std;

bool isOperator(char ch) {
    return ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '%';
}

bool isOperator(const string& str) {
    return str == "+" || str == "-" || str == "*" || str == "/" || str == "%";
}

string removeWhitespace(const string& str) {
    string result;
    for (char ch : str) {
        if (!isspace(ch)) {
            result.push_back(ch);
        }
    }
    return result;
}

vector<string> convertToInfix(const string& input) {
    vector<string> infix;
    string num;
    bool expectUnary = true; // flag to track unary minus

    for (size_t i = 0; i < input.size(); ++i) {
        char ch = input[i];
        if (isdigit(ch) || (ch == '.' && !num.empty())) {
            num += ch;
            expectUnary = false;
        } else {
            if (!num.empty()) {
                infix.push_back(num);
                num.clear();
            }
            if (ch == '(') {
                infix.push_back(string(1, ch));
                expectUnary = true;
            } else if (ch == ')') {
                infix.push_back(string(1, ch));
                expectUnary = false;
            } else if (isOperator(ch)) {
                if (ch == '-' && expectUnary) {
                    num += ch;
                } else {
                    infix.push_back(string(1, ch));
                    expectUnary = true;
                }
            }
        }
    }
    if (!num.empty()) {
        infix.push_back(num);
    }

    return infix;
}

int checkPrecedence(const string& op) {
    if (op == "*" || op == "/" || op == "%") return 3;
    if (op == "+" || op == "-") return 2;
    return 1;
}

vector<string> convertToPostfix(const vector<string>& infix) {
    stack<string> operators;
    vector<string> postfix;

    for (const string& token : infix) {
        if (isdigit(token[0]) || (token[0] == '-' && token.size() > 1 && isdigit(token[1])) || (token[0] == '.' && token.size() > 1 && isdigit(token[1]))) {
            postfix.push_back(token);
        } else if (token == "(") {
            operators.push(token);
        } else if (token == ")") {
            while (!operators.empty() && operators.top() != "(") {
                postfix.push_back(operators.top());
                operators.pop();
            }
            operators.pop();
        } else if (isOperator(token)) {
            while (!operators.empty() && checkPrecedence(operators.top()) >= checkPrecedence(token)) {
                postfix.push_back(operators.top());
                operators.pop();
            }
            operators.push(token);
        }
    }

    while (!operators.empty()) {
        postfix.push_back(operators.top());
        operators.pop();
    }

    return postfix;
}

double doOperation(double a, double b, const string& op) {
    if (op == "+") return a + b;
    if (op == "-") return a - b;
    if (op == "*") return a * b;
    if (op == "/") return a / b;
    if (op == "%") return fmod(a, b);
    return 0;
}

double evaluatePostfix(const vector<string>& postfix) {
    stack<double> result;

    for (const string& token : postfix) {
        if (isOperator(token)) {
            double a = result.top(); result.pop();
            double b = result.top(); result.pop();
            result.push(doOperation(b, a, token));
        } else {
            result.push(stod(token));
        }
    }

    return result.top();
}

int main() {
    string input;
    getline(cin, input);

    string noSpaces = removeWhitespace(input);
    vector<string> infix = convertToInfix(noSpaces);
    vector<string> postfix = convertToPostfix(infix);

    cout << evaluatePostfix(postfix) << endl;

    return 0;
}
